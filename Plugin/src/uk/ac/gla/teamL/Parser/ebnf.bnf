// This was created using guidance from http://jflex.de/manual.html
// and https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md

{

	parserClass="uk.ac.gla.teamL.parser.EBNFParser"
    parserUtilClass="uk.ac.gla.teamL.parser.EBNFParserUtil"

    implements="uk.ac.gla.teamL.parser.psi.EBNFCompositeElement"
    extends="uk.ac.gla.teamL.parser.psi.impl.EBNFCompositeElementImpl"

	psiClassPrefix="EBNF"
	psiImplClassSuffix="Impl"
	psiPackage="uk.ac.gla.teamL.parser.psi"
	psiImplPackage="uk.ac.gla.teamL.parser.psi.impl"

	elementTypeHolderClass="uk.ac.gla.teamL.parser.psi.EBNFTypes"
	elementTypeClass="uk.ac.gla.teamL.parser.psi.EBNFElementType"
	tokenTypeClass="uk.ac.gla.teamL.parser.psi.EBNFTokenType"

	tokens = [

		LET = 'let'

		comment_singleline = "regexp://[^\n]*"
		comment_block = "regexp:/\*[^*/\*]*\*/"

		// Match all characters except the outer character, unless it is
		// escaped using the '\' character.
		// Strings can be enclosed in: "..." OR '''...'''
		string_tripleQuotes = "regexp:'''([^(''')]|(\\'))*'''"
		string_doubleQuotes = 'regexp:"([^"\\"]|\\.)*"'
		string_singleQuotes = "regexp:'([^(')]|(\\\\'))*'"

		EQ = '='
		OR = '|'

		LB = '('
		RB = ')'
		LOB = '{'
		ROB = '}'
		LSB = '['
		RSB = ']'

		ZERO_OR_MORE = "*"
		ZERO_OR_ONE = "?"
		ONE_OR_MORE = "+"

		RANGE_OPERATOR = '..'
		NEGATION_OPERATOR = '!'
		ANY_OPERATOR = '.'

		LIST_SEPERATOR = ","

		TERMINAL = ";"

		ID = "regexp:[a-zA-Z][_a-zA-Z0-9]*"

		NUMBER = "regexp:[0-9]"
	]
}

program ::= assignment*

assignment ::=  let identifier EQ rules terminal {
	mixin = "uk.ac.gla.teamL.parser.psi.impl.EBNfAssignmentImplUtil"
	pin = rules
	recoverWhile = assignment_recover
}

assignment_recover ::= !(let | terminal)

rules ::= rule+ (OR rules)? {
	pin = rule
	recoverWhile = rules_recover
}

rules_recover ::= !(terminal|let|ROB|RSB|RB)

rule ::= predicate?
	   ( string
	   | identifier
	   | range
	   | nestedRules
	   | any
	   ) quantifier?

nestedRules ::= LB rules RB

predicate ::= NEGATION_OPERATOR

quantifier ::= ZERO_OR_MORE
			 | ZERO_OR_ONE
			 | ONE_OR_MORE
			 | arbitraryQuantifier

arbitraryQuantifier ::= LSB NUMBER (LIST_SEPERATOR NUMBER)? RSB

any ::= ANY_OPERATOR

// I really cant think of anyway to match multiple alternative ranges in this.
range ::= RSB (string RANGE_OPERATOR string)+ LSB {
	mixin = "uk.ac.gla.teamL.parser.psi.impl.EBNFRangeImplUtil"
}

string ::= string_tripleQuotes
		 | string_doubleQuotes
		 | string_singleQuotes {
	mixin = "uk.ac.gla.teamL.parser.psi.impl.EBNFStringImplUtil"
}

identifier ::= ID {
	mixin = "uk.ac.gla.teamL.parser.psi.impl.EBNFIdentifierImplUtil"
}

