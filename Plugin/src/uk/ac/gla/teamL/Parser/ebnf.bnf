// This was created using guidance from http://jflex.de/manual.html
// and https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md

{

	parserClass="uk.ac.gla.teamL.parser.EBNFParser"
    parserUtilClass="uk.ac.gla.teamL.parser.EBNFParserUtil"

    implements="uk.ac.gla.teamL.psi.EBNFCompositeElement"
    extends="uk.ac.gla.teamL.psi.impl.EBNFCompositeElementImpl"

	psiClassPrefix="EBNF"
	psiImplClassSuffix="Impl"
	psiPackage="uk.ac.gla.teamL.psi"
	psiImplPackage="uk.ac.gla.teamL.psi.impl"
	psiImplUtilClass="uk.ac.gla.teamL.psi.impl.EBNFParserImplUtil"

	elementTypeHolderClass="uk.ac.gla.teamL.psi.EBNFTypes"
	elementTypeClass="uk.ac.gla.teamL.psi.EBNFElementType"
	tokenTypeClass="uk.ac.gla.teamL.psi.EBNFTokenType"

	name("string*") = "String"

	tokens = [

		LET = 'let'

		comment_singleline = "regexp://[^\n]*"
		comment_block = "regexp:/\*[^*/\*]*\*/"

		// Match all characters except the outer character, unless it is
		// escaped using the '\' character.
		// Strings can be enclosed in: "..." OR '''...'''
		string_tripleQuotes = "regexp:'''([^(''')]|(\\'))*'''"
		string_doubleQuotes = 'regexp:"([^"\\"]|\\.)*"'
		string_singleQuotes = "regexp:'([^(')]|(\\\\'))*'"

		EQ = '='
		OR_OPERATOR = '|'

		LB = '('
		RB = ')'
		LCB = '{'
		RCB = '}'
		LSB = '['
		RSB = ']'

		ZERO_OR_MORE = "*"
		ZERO_OR_ONE = "?"
		ONE_OR_MORE = "+"

		RANGE_OPERATOR = '..'
		NEGATION_OPERATOR = '!'
		ANY_OPERATOR = '.'

		LIST_SEPERATOR = ","

		TERMINAL = ";"

		ANNOTATION_OPERATOR = "@"

		ID = "regexp:[a-zA-Z][_a-zA-Z0-9]*"

		NUMBERS = "regexp:[0-9]+"
	]
}

program ::= assignment * {
	pin = assignment
	recoverWhile = assignment_recover
	methods = [
		getRules = "\assignment"
	]
}

annotation ::= ANNOTATION_OPERATOR ID {
	methods = [
		getName
	]
}

assignment ::=  annotation* let identifier EQ rules terminal {
	pin = rules
	recoverWhile = assignment_recover
	methods = [
		toString
		getName
		ID="identifier"
	]
}

assignment_recover ::= !(let | terminal | LSB | RSB | LB | RB | LCB | RCB | ANNOTATION_OPERATOR)

rules ::= ruleElement (or? ruleElement)*;

ruleElement ::= predicate?
	          ( string
	          | identifier
	          | range
	          | nestedRules
	          | any
	          ) quantifier? {
	name = "element"
}

nestedRules ::= LB rules RB

predicate ::= NEGATION_OPERATOR

quantifier ::= ZERO_OR_MORE
			 | ZERO_OR_ONE
			 | ONE_OR_MORE
			 | arbitraryQuantifier

arbitraryQuantifier ::= LCB num (LIST_SEPERATOR num)? RCB {
	methods = [
		getLowerBound = "/num[0]"
		getUpperBound = "/num[1]"
	]
}

num ::= NUMBERS {
	methods = [getValue]
}

any ::= ANY_OPERATOR

or ::= OR_OPERATOR

range ::= LSB string RANGE_OPERATOR string RSB {
	methods = [
		getLowerBound="/string[0]"
		getUpperBound="/string[1]"
	]
}

string ::= string_tripleQuotes
		 | string_doubleQuotes
		 | string_singleQuotes {
	methods = [getString]
}

identifier ::= ID {
	mixin="uk.ac.gla.teamL.psi.impl.EBNFNamedElementImpl"
	implements="uk.ac.gla.teamL.psi.EBNFNamedElement"
	methods=[
		toString
		getName
		setName
		getNameIdentifier
	]
}
